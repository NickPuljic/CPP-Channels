#include "../chan.h"
#include <iostream>
//#include <random>
#include <chrono>

// probably, senders will exit earlier than the recvers.
template<typename T>
void do_send(
	Chan<T>& chan, 
	std::vector<T>& sender_data,
	std::chrono::microseconds& elapsed) {

    auto start = std::chrono::high_resolution_clock::now();
    for (auto data : sender_data) {
        chan.send(data);
    }
    elapsed = std::chrono::duration_cast<std::chrono::microseconds>(
    	std::chrono::high_resolution_clock::now() - start);
}

template<typename T>
void do_recv(
	Chan<T>& chan, 
	std::vector<T>& recver_data,
	std::chrono::microseconds& elapsed,
	std::atomic<unsigned>& recv_count,
	unsigned& n_data,
	std::condition_variable& all_recved_cond) {
    
	T data;
	bool received;
	while (true) {
		auto start = std::chrono::high_resolution_clock::now();
		received = chan.recv(data);
		elapsed += std::chrono::duration_cast<std::chrono::microseconds>(
			std::chrono::high_resolution_clock::now() - start);
		if (received) {
			recver_data.push_back(data);
			recv_count += 1;
			// TODO non-atomic btw ++ and load ok?
			if (recv_count == n_data) {
				// last data recieved. notify main thread to close.
				all_recved_cond.notify_one();
				break;
			}
		} else { // channel closed
			break;
		}
	}
}

template<typename T, typename RandomFunctor>
void measure_parallel_send_and_recv(
	RandomFunctor random_functor,
    unsigned buffer_sz = 0,
    unsigned n_senders = 3,
    unsigned n_recvers = 3,
    unsigned n_data = 1000,
    bool debug = false,
    bool is_T_comparable = false) {

    assert((n_senders > 0 && n_recvers > 0 && n_data > 10));

    Chan<T> chan(buffer_sz);

    //////////////////////////////////////////////////////////////////////////////// 
    // Data & Container Generation

    // all_sender_data contains n_data of type T, each generated by random_functor.
    std::vector<T> all_sender_data;
    for (auto i = 0; i < n_data; ++i) {
    	all_sender_data.push_back(random_functor());
    }

    // split it (almost) equally among (except for last) senders.
    std::vector<std::vector<T>> each_sender_data;
    const std::size_t each_sender_data_size = all_sender_data.size() / n_senders;
    auto begin = all_sender_data.begin();
    for (auto i = 0; i < n_senders; ++i) {
        auto end = i == n_senders - 1 ? all_sender_data.end() : begin + each_sender_data_size;
        each_sender_data.push_back(std::vector<T>(begin, end));
        begin = end;
    }

    // n_recvers vectors for recvers to fill.
    std::vector<std::vector<T>> each_recver_data(n_recvers, std::vector<T>(0));

    // elapsed time to be returned by threads.
    std::vector<std::chrono::microseconds> each_sender_duration(n_senders);
    std::vector<std::chrono::microseconds> each_recver_duration(n_recvers);

    //////////////////////////////////////////////////////////////////////////////// 
    // Send and Recv

    std::atomic<unsigned> recv_count{0};
    std::condition_variable all_recved_cond;
    std::mutex all_recved_mutex;

    // threads to join later.
    std::vector<std::thread> threads;

    // launch all senders.
    for (auto i = 0; i < n_senders; ++i){
        //std::thread t{send_all, std::ref(chan), std::ref(each_sender_data[i])};
        threads.push_back(std::thread(
        	do_send, 
        	std::ref(chan), 
        	std::ref(each_sender_data[i]),
        	std::ref(each_sender_duration[i]) ));
    }

    // launch all recvers.
    for (auto i = 0; i < n_recvers; ++i) {
        //std::thread t{recv_for_seconds, std::ref(chan), std::ref(each_recver_data[i]), std::ref(recv_for)};
        threads.push_back(std::thread(
        	do_recv, 
        	std::ref(chan), 
        	std::ref(each_recver_data[i]), 
        	std::ref(each_recver_duration[i]),
        	std::ref(recv_count),
        	std::ref(n_data),
        	std::ref(all_recved_cond) ));
    }

    // one recver will recv last element, and increment recv_count to 1000.
    // then, that recver will notify this main thread.
    // upon wakeup, the main thread closes the channel, so that other recvers can also exit.
    // why lock? condition variables require use of lock, and we can't use future/promise pair here.
    std::unique_lock<std::mutex> lck {all_recved_mutex};
    all_recved_cond.wait(lck);
    lck.unlock();

    chan.close();

    // wait for all senders and recvers to finish.
    for (auto i = 0; i < threads.size(); ++i) {
    	threads[i].join();
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Sanity check
    
    if (debug == true) {
    	int recved_data_count = 0;
    	for (auto recver_data : each_recver_data) {
    		recved_data_count += recver_data.size();
    	}

    	assert(recved_data_count == n_data);

    	/*
    	if (is_T_comparable == true) {
		    // merge each_recver_data
		    std::vector<T> all_recver_data;
		    for (auto recver_data : each_recver_data) {
		        all_recver_data.insert(all_recver_data.end(), recver_data.begin(), recver_data.end());
		    }

		    std::sort(all_recver_data.begin(), all_recver_data.end());
		    std::sort(all_sender_data.begin(), all_sender_data.end());
		    assert(all_recver_data == all_sender_data);
		}
		*/
	}

	////////////////////////////////////////////////////////////////////////////////
	// Output results to StdErr for data collection in .csv


}

int main() {
	measure_parallel_send_and_recv();
}