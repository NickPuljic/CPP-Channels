#include "../chan.h"
#include <iostream>
#include <random>
#include <chrono>

// probably, senders will exit earlier than the recvers.
template<typename T>
void do_send(
	Chan<T>& chan, 
	std::vector<T>& sender_data,
	std::chrono::microseconds& elapsed) {

    auto start = std::chrono::high_resolution_clock::now();
    for (auto data : sender_data) {
        chan.send(data);
    }
    elapsed = std::chrono::duration_cast<std::chrono::microseconds>(
    	std::chrono::high_resolution_clock::now() - start);
}

template<typename T>
void do_recv(
	Chan<T>& chan, 
	std::vector<T>& recver_data,
	std::chrono::microseconds& elapsed,
	std::atomic<unsigned>& recv_count,
	unsigned& n_data,
	std::condition_variable& all_recved_cond) {
    
	T data;
	bool received;
	while (true) {
		auto start = std::chrono::high_resolution_clock::now();
		received = chan.recv(data);
		elapsed += std::chrono::duration_cast<std::chrono::microseconds>(
			std::chrono::high_resolution_clock::now() - start);
		if (received) {
			recver_data.push_back(data);
			recv_count += 1;
			// TODO non-atomic btw ++ and load ok?
			if (recv_count == n_data) {
				// last data recieved. notify main thread to close.
				all_recved_cond.notify_one();
				break;
			}
		} else { // channel closed
			break;
		}
	}
}

void print_duration_vector(std::vector<std::chrono::microseconds>& v) {
	for (auto i = 0; i < v.size(); ++i) {
		std::cout << v[i].count();
		if (i < v.size() - 1) {
			std::cout << ",";
		}
	}
	std::cout << std::endl;
}

std::pair<double, double> get_mean_stdev(std::vector<std::chrono::microseconds>& v) {
    std::vector<unsigned> results;
    for (auto microsecs : v) {
        results.push_back(microsecs.count());
    }
    double sum = std::accumulate(results.begin(), results.end(), 0.0);
    double mean = sum / results.size();
    double sum_of_squares = std::inner_product(results.begin(), results.end(), results.begin(), 0.0);
    double stdev = std::sqrt(sum_of_squares / results.size() - mean * mean);
    return std::pair<double, double>(mean, stdev);
}

double get_mean(std::vector<std::chrono::microseconds>& v) {
    std::vector<unsigned> results;
    for (auto microsecs : v) {
        results.push_back(microsecs.count());
    }
    double sum = std::accumulate(results.begin(), results.end(), 0.0);
    double mean = sum / results.size();
    return mean;
}

template<typename T, typename RandomFunctor>
void measure_parallel_send_and_recv(
	RandomFunctor random_functor,
	// this sucks, but getting type name requires cxxabi.h or boost.
	std::string name_of_T,
	// be careful of argument order. TODO use strong types.
    unsigned buffer_sz = 0,
    unsigned n_senders = 3,
    unsigned n_recvers = 3,
    unsigned n_data = 100000,
    bool debug = true) {
    // bool is_T_comparable = false) {

    assert((n_senders > 0 && n_recvers > 0 && n_data > 100));

    Chan<T> chan(buffer_sz);

    //////////////////////////////////////////////////////////////////////////////// 
    // Data & Container Generation

    // all_sender_data contains n_data of type T, each generated by random_functor.
    std::vector<T> all_sender_data;
    for (auto i = 0; i < n_data; ++i) {
    	all_sender_data.push_back(random_functor());
    }

    // split it (almost) equally among (except for last) senders.
    std::vector<std::vector<T>> each_sender_data;
    const std::size_t each_sender_data_size = all_sender_data.size() / n_senders;
    auto begin = all_sender_data.begin();
    for (auto i = 0; i < n_senders; ++i) {
        auto end = i == n_senders - 1 ? all_sender_data.end() : begin + each_sender_data_size;
        each_sender_data.push_back(std::vector<T>(begin, end));
        begin = end;
    }

    // n_recvers vectors for recvers to fill.
    std::vector<std::vector<T>> each_recver_data(n_recvers, std::vector<T>(0));

    // elapsed time to be returned by threads.
    std::vector<std::chrono::microseconds> each_sender_duration(n_senders);
    std::vector<std::chrono::microseconds> each_recver_duration(n_recvers);

    //////////////////////////////////////////////////////////////////////////////// 
    // Send and Recv

    std::atomic<unsigned> recv_count{0};
    std::condition_variable all_recved_cond;
    std::mutex all_recved_mutex;

    // threads to join later.
    std::vector<std::thread> threads;

    // launch all senders.
    for (auto i = 0; i < n_senders; ++i){
    	std::thread t{
        	do_send<int>, 
        	std::ref(chan), 
        	std::ref(each_sender_data[i]),
        	std::ref(each_sender_duration[i])
        };
        threads.push_back(std::move(t));
    }

    // launch all recvers.
    for (auto i = 0; i < n_recvers; ++i) {
        //std::thread t{recv_for_seconds, std::ref(chan), std::ref(each_recver_data[i]), std::ref(recv_for)};
        std::thread t{
        	do_recv<int>, 
        	std::ref(chan), 
        	std::ref(each_recver_data[i]), 
        	std::ref(each_recver_duration[i]),
        	std::ref(recv_count),
        	std::ref(n_data),
        	std::ref(all_recved_cond)
        };
        threads.push_back(std::move(t));
    }

    // one recver will recv last element, and increment recv_count to 1000.
    // then, that recver will notify this main thread.
    // upon wakeup, the main thread closes the channel, so that other recvers can also exit.
    // why lock? condition variables require use of lock, and we can't use future/promise pair here.
    std::unique_lock<std::mutex> lck {all_recved_mutex};
    all_recved_cond.wait(lck);
    lck.unlock();

    chan.close();

    // wait for all senders and recvers to finish.
    for (auto i = 0; i < threads.size(); ++i) {
    	threads[i].join();
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Sanity check
    
    if (debug == true) {
    	int recved_data_count = 0;
    	for (auto recver_data : each_recver_data) {
    		recved_data_count += recver_data.size();
    	}

    	assert(recved_data_count == n_data);

    	/* if T is not comparable, this will fail at compile time?
    	if (is_T_comparable == true) {
		    // merge each_recver_data
		    std::vector<T> all_recver_data;
		    for (auto recver_data : each_recver_data) {
		        all_recver_data.insert(all_recver_data.end(), recver_data.begin(), recver_data.end());
		    }

		    std::sort(all_recver_data.begin(), all_recver_data.end());
		    std::sort(all_sender_data.begin(), all_sender_data.end());
		    assert(all_recver_data == all_sender_data);
		}
		*/
	}

	////////////////////////////////////////////////////////////////////////////////
	// Output results for data collection in .csv
	// ex: g++ -std=c++11 ParallelSendRecv.cpp -o psr; ./psr > out.csv

    auto send_mean = get_mean(each_sender_duration);
    auto recv_mean = get_mean(each_recver_duration);

    std::cout << buffer_sz << "," 
        << n_senders << "," 
        << n_recvers << "," 
        << n_data << "," 
        << name_of_T << ","
        << send_mean << ","
        << recv_mean << std::endl;
        //<< send_mean_stdev.second << ","
        //<< recv_mean_stdev.second << ","
}

////////////////////////////////////////////////////////////////////////////////
// Random Functors

// 1. int (see textbook 14.5)
class Rand_int {
private:
	std::default_random_engine random_engine;
	std::uniform_int_distribution<> distribution;
public:
	Rand_int(int low, int high) : distribution{low, high} {
		random_engine.seed(std::chrono::system_clock::now().time_since_epoch().count());
	}
	int operator()() {
		return distribution(random_engine);
	}
};

////////////////////////////////////////////////////////////////////////////////
// Experiments

int main() {
    // column titles.
    std::cout << "buffer size,"
        "number of senders,"
        "number of recvers,"
        "number of data,"
        "data type," 
        "sender duartion mean,"
        "recver duartion mean" << std::endl;
        //"sender duartion standard deviation,"
        //"recver duartion standard deviation" << std::endl;

	// be careful of argument order.
	Rand_int rnd {0, 100000000};

    std::vector<unsigned> data_sizes{1000, 10000, 100000};
    std::vector<unsigned> buffer_sizes{0, 10, 50};

    for (auto n_senders = 1; n_senders <= 4; ++n_senders) {
        for (auto n_recvers = 1; n_recvers <= 4; ++n_recvers) {
            for (auto n_data : data_sizes) {
                for (auto buffer_size : buffer_sizes) {
                    measure_parallel_send_and_recv<int>(
                        rnd, 
                        "int",
                        buffer_size,
                        n_senders,
                        n_recvers,
                        n_data);
                }
            }
        }
    }

	//measure_parallel_send_and_recv<int>(rnd, "int");
	//measure_parallel_send_and_recv<int>(rnd, "int", 0, 3, 3, 1000);
}
